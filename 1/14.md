[Оглавление](../index.md)  

## 1.4. Определение версий ОС и ядра. Системные вызовы и библиотеки.

### **1.1. Что есть что?**
- **Ядро (Kernel)** — центральная часть ОС, управляющая аппаратными ресурсами
- **Операционная система (ОС)** = Ядро + Системные утилиты + Библиотеки + Дополнительное ПО

### **1.2. Как определить версию ядра Linux?**
```bash
# Основные команды:
uname -r                  # Только версия ядра (например, 5.15.0-91-generic)
uname -a                  # Вся информация: ядро, хост, архитектура и т.д.

# Более подробная информация о ядре:
cat /proc/version         # Информация о компиляции ядра
hostnamectl               # В systemd-системах показывает версию ядра и ОС

# Для старых систем:
dmesg | grep Linux        # Первые строки загрузки ядра
```

**Формат версии ядра Linux:**
```
5 . 15 . 0 - 91 - generic
│   │    │    │      │
│   │    │    │      └── вариант сборки/патчи дистрибутива
│   │    │    └───────── номер сборки/ревизия
│   │    └────────────── патч (patch level)
│   └─────────────────── минорная версия
└─────────────────────── мажорная версия
```

**Нумерация до версии 3.0:**
- Четные минорные версии (2.6, 2.8) — стабильные
- Нечетные (2.7, 2.9) — разрабатываемые

**С 2011 года (версия 3.0):** линейная нумерация.

### **1.3. Как определить версию дистрибутива (ОС)?**
```bash
# Для Debian/Ubuntu и производных:
lsb_release -a           # Полная информация (требует установки lsb-release)
cat /etc/os-release      # Стандартный файл (работает везде)
cat /etc/debian_version  # Только для Debian
cat /etc/lsb-release     # Для Ubuntu

# Для Red Hat/CentOS/Fedora:
cat /etc/redhat-release
cat /etc/fedora-release
cat /etc/system-release

# Для openSUSE:
cat /etc/SuSE-release
cat /etc/os-release

# Для Arch:
cat /etc/arch-release   # Пустой файл, но если он есть - это Arch

# Для Alpine:
cat /etc/alpine-release

# Общие методы:
hostnamectl              # Работает в systemd-системах
cat /etc/*-release       # Показывает все release-файлы
cat /etc/issue           # Информация о дистрибутиве
```

### **1.4. Практический пример:**
```bash
$ uname -r
5.15.0-91-generic

$ cat /etc/os-release
NAME="Ubuntu"
VERSION="22.04.3 LTS (Jammy Jellyfish)"
ID=ubuntu
ID_LIKE=debian
PRETTY_NAME="Ubuntu 22.04.3 LTS"
VERSION_ID="22.04"
```

## 2. Системные вызовы (System Calls)

### **2.1. Что такое системные вызовы?**
- **Интерфейс между пользовательским пространством и ядром**
- Единственный легальный способ запросить услуги ядра
- Около 300-400 системных вызовов в Linux (зависит от архитектуры)

### **2.2. Как работают?**
1. Программа в пользовательском пространстве вызывает библиотечную функцию (например, `open()`)
2. Библиотека помещает аргументы в регистры процессора
3. Выполняется инструкция `syscall` / `int 0x80` (x86) / `svc` (ARM)
4. Процессор переключается в режим ядра
5. Ядро выполняет запрошенную операцию
6. Возврат в пользовательское пространство с результатом

### **2.3. Примеры распространенных системных вызовов:**
```c
// Базовые операции с файлами
open(), read(), write(), close()
stat(), fstat(), lseek()

// Управление процессами
fork(), execve(), exit()
wait(), waitpid()
kill(), signal()

// Управление памятью
brk(), mmap(), munmap()
mprotect()

// Сетевые операции
socket(), bind(), connect()
accept(), send(), recv()

// IPC (межпроцессное взаимодействие)
pipe(), shmget(), msgget()
semop()
```

### **2.4. Просмотр системных вызовов:**
```bash
# Список системных вызовов для текущей архитектуры:
ausyscall --dump        # Требует установки auditd

# Или посмотреть заголовочные файлы:
less /usr/include/asm/unistd_64.h    # Для x86_64
less /usr/include/asm/unistd_32.h    # Для x86

# Трассировка системных вызовов программы:
strace ls /tmp          # Показать все syscalls, которые делает ls
strace -c ls /tmp       # Статистика вызовов
strace -e open ls /tmp  # Только определенные syscalls

# Для уже запущенного процесса:
strace -p PID
```

### **2.5. Номера системных вызовов:**
```c
// Пример: x86_64
#define __NR_read         0
#define __NR_write        1
#define __NR_open         2
#define __NR_close        3
#define __NR_fork         57
#define __NR_execve       59
// и т.д.
```

## 3. Библиотеки (Libraries)

### **3.1. Основные типы библиотек:**
1. **Статические (.a)** — линкуются на этапе компиляции
2. **Динамические (.so)** — линкуются во время выполнения

### **3.2. Ключевые системные библиотеки:**

#### **GNU C Library (glibc)**
```bash
# Версия glibc:
ldd --version
/lib/x86_64-linux-gnu/libc.so.6
getconf GNU_LIBC_VERSION

# Основные компоненты glibc:
# - Стандартные функции C (stdio, stdlib, string)
# - Обертки для системных вызовов
# - Функции интернационализации
# - Математические функции
# - Управление памятью (malloc/free)
```

#### **Другие важные библиотеки:**
```bash
# Динамический линкер:
/lib64/ld-linux-x86-64.so.2    # Для x86_64

# Потоки (pthreads):
libpthread.so.0

# Математика:
libm.so.6

# Загрузка динамических библиотек:
libdl.so.2

# Криптография:
libcrypto.so, libssl.so

# Графика:
libX11.so, libGL.so
```

### **3.3. Работа с библиотеками:**
```bash
# Просмотр библиотек, от которых зависит программа:
ldd /bin/ls                    # Список всех динамических библиотек
objdump -p /bin/ls | grep NEEDED  # Альтернативный способ

# Поиск библиотек в системе:
ldconfig -p | grep libc        # Кэш библиотек
find /usr -name "*.so*"        # Все библиотеки

# Переменные окружения для библиотек:
LD_LIBRARY_PATH=/my/libs:$LD_LIBRARY_PATH  # Дополнительные пути
LD_PRELOAD=/my/lib.so          # Предзагрузка библиотеки
LD_DEBUG=libs program          # Отладка загрузки библиотек

# Создание и использование:
# Компиляция с динамической библиотекой:
gcc -o program program.c -lm   # линковка с математической библиотекой

# Компиляция со статической линковкой:
gcc -static -o program program.c
```

### **3.4. Взаимосвязь: Приложение → Библиотеки → Системные вызовы → Ядро**

```
┌─────────────────────────────────────────────────────┐
│                Пользовательское пространство        │
├─────────────────────────────────────────────────────┤
│ Приложение → Стандартная библиотека C (glibc)       │
│          (например, printf()) → write() обертка     │
└─────────────────────────────────────────────────────┘
                            ↓ (syscall)
┌─────────────────────────────────────────────────────┐
│                 Ядро (Kernel Space)                 │
├─────────────────────────────────────────────────────┤
│ Обработка системного вызова sys_write()             │
│ Управление драйверами устройств                     │
└─────────────────────────────────────────────────────┘
```

### **3.5. Пример трассировки вызова:**
```c
// Программа:
printf("Hello, World!\n");

// Что происходит:
1. printf() (в glibc) форматирует строку
2. Вызывает write() обертку в glibc
3. glibc вызывает системный вызов SYS_write (номер 1 на x86_64)
4. Ядро получает управление, копирует данные из пользовательского
   пространства в буфер ядра
5. Драйвер TTY/файловой системы выводит данные
6. Возврат в пользовательское пространство
```

### **3.6. Современные альтернативы:**
- **musl-libc** — легкая реализация стандартной библиотеки C
- **uclibc-ng** — для встраиваемых систем
- **Bionic** — библиотека C от Android (на основе BSD)

## 4. Полезные команды для анализа

```bash
# Узнать все о системе:
uname -a                    # Ядро и архитектура
lsb_release -a              # Дистрибутив
cat /proc/version           # Детали ядра
cat /proc/sys/kernel/osrelease  # Версия ядра

# Анализ системных вызовов:
strace -tt -T -o trace.log программа  # Детальная трассировка
ltrace программа                     # Трассировка библиотечных вызовов

# Анализ библиотек:
readelf -d /bin/ls | grep NEEDED     # Зависимости
nm -D /lib/libc.so.6 | grep printf   # Символы в библиотеке
```

**Ключевой вывод:** Понимание взаимосвязи между приложением, библиотеками, системными вызовами и ядром критически важно для:
- Отладки сложных проблем
- Оптимизации производительности
- Разработки системного ПО
- Анализа безопасности

[Оглавление](../index.md)  